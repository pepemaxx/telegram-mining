
<!doctype html>
<html lang="en" dir="ltr">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PiProtocol \u2013 Daily Mining</title>
  <style>
/* ====== Theme ====== */
:root{
  --bg1:#4c1d95; --bg2:#7b2cbf; --ink:#fff; --muted:#cbd5e1;
  --brand:#f1c40f; --border:rgba(255,255,255,.18); --card:rgba(255,255,255,.08);
  --good:#10b981; --warn:#f59e0b; --danger:#ef4444;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; color:var(--ink); font-family:Inter, Segoe UI, Roboto, system-ui, -apple-system, sans-serif;
  background: radial-gradient(1200px 1200px at 70% -10%, rgba(255,255,255,.12), transparent 40%),
              linear-gradient(180deg,var(--bg1),var(--bg2));
  overflow:hidden;
}
body::after{
  content:""; position:fixed; inset:0; pointer-events:none; z-index:0;
  background:
    radial-gradient(400px 400px at 50% 30%, rgba(255,255,255,.12), transparent 60%),
    url('https://i.imgur.com/8L1Xk6D.png') center 24%/280px no-repeat;
  opacity:.06; filter: saturate(1.2);
}
#app{position:relative; z-index:1; height:100%; display:flex; flex-direction:column}
header{
position:sticky; top:0; z-index:5; background:rgba(0,0,0,.18); backdrop-filter:blur(10px);
border-bottom:1px solid var(--border); padding:12px 16px; display:flex; align-items:center; justify-content:space-between
}
.title{font-weight:900; font-size:18px; letter-spacing:.2px}
.sub{font-size:12px; color:var(--muted)}
main{flex:1; overflow-y:auto; padding:16px 16px 100px; max-width:980px; margin:0 auto; width:100%}

/* Cards */
.card{
background:var(--card); border:1px solid var(--border); border-radius:18px; padding:16px;
box-shadow: 0 8px 30px rgba(0,0,0,.20), inset 0 1px 0 rgba(255,255,255,.04);
backdrop-filter: blur(8px);
}
.row{display:flex; align-items:center; justify-content:space-between; gap:14px; flex-wrap:wrap}
.grid-2{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:12px}
.grid-3{display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:12px}
@media (max-width:720px){ .grid-2,.grid-3{grid-template-columns:1fr} }

.big{font-size:28px; font-weight:900}
.kicker{font-size:12px; letter-spacing:.6px; color:var(--muted); font-weight:800; text-transform:uppercase}
.muted{color:var(--muted); font-size:12px}
.accent{color:var(--brand)}

/* Buttons & Inputs */
.btn{border:none; border-radius:14px; padding:10px 14px; font-weight:800; cursor:pointer; transition:transform .05s ease, filter .2s}
.btn:active{transform: translateY(1px)}
.btn-gold{background:linear-gradient(135deg,#fde047,#f59e0b); color:#3b0764}
.btn-ghost{background:rgba(255,255,255,.10); color:#fff; border:1px solid var(--border)}
.btn-danger{background:linear-gradient(135deg,#fca5a5,#ef4444); color:#3b0764}
.btn:disabled{opacity:.6; cursor:not-allowed}

input, select{
background:rgba(255,255,255,.10); color:#fff; border:1px solid var(--border); border-radius:12px;
padding:10px 12px; outline:none; width:100%
}
input::placeholder{color:#cbd5e1}
.input-row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}

/* Status & progress */
.pill{font-size:12px; padding:4px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(255,255,255,.06)}
.pill.good{background:rgba(16,185,129,.18); border-color:rgba(16,185,129,.4); color:#d1fae5}
.pill.warn{background:rgba(245,158,11,.16); border-color:rgba(245,158,11,.45)}
.pill.bad{background:rgba(239,68,68,.16); border-color:rgba(239,68,68,.45)}

.progress{height:10px; border-radius:999px; background:rgba(255,255,255,.18); overflow:hidden}
.progress>div{height:100%; background:linear-gradient(90deg,#fde047,#f59e0b); width:0%; transition: width .25s}

/* Tabs bar */
nav.tabs{position:fixed; left:0; right:0; bottom:0; border-top:1px solid var(--border); background:rgba(0,0,0,.22); backdrop-filter:blur(10px); z-index:5}
.tabs-inner{max-width:980px; margin:0 auto; height:72px; display:grid; grid-template-columns:repeat(5,1fr)}
.tab-btn{appearance:none; background:none; border:none; color:#e2e8f0; font-size:13px; display:flex; align-items:center; justify-content:center; gap:6px; flex-direction:column}
.tab-btn .mini{font-size:11px; opacity:.85}
.tab-btn.active{color:var(--brand)}
section.tab{display:none}
section.tab.active{display:block}

/* Tables */
.table{width:100%; border-collapse:collapse}
.table th, .table td{padding:10px; border-bottom:1px solid var(--border); text-align:left}
.table th{color:#f8fafc; font-weight:800; font-size:12px; opacity:.9}

/* Badges */
.badge{display:inline-flex; align-items:center; gap:6px; background:rgba(255,255,255,.08); border:1px solid var(--border); padding:6px 10px; border-radius:999px; font-size:12px}

/* Nice section headers */
.h3{font-size:16px; font-weight:900; margin:0 0 8px}
.h2{font-size:18px; font-weight:900; margin:0 0 10px}

/* Icon (inline) */
.icon{width:18px; height:18px; opacity:.9}

/* Share Modal */
.share-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.7);
  z-index: 100;
  justify-content: center;
  align-items: center;
}

.share-modal-content {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 18px;
  padding: 20px;
  width: 90%;
  max-width: 400px;
  backdrop-filter: blur(10px);
}

.share-apps {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  margin-top: 15px;
}

.share-app {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px;
  background: rgba(255,255,255,0.1);
  border-radius: 12px;
  cursor: pointer;
  transition: background 0.2s;
}

.share-app:hover {
  background: rgba(255,255,255,0.2);
}

.share-app svg {
  width: 30px;
  height: 30px;
  margin-bottom: 5px;
}

.share-app span {
  font-size: 12px;
}
</style>
  <script src="https://sites.super.myninja.ai/_assets/ninja-daytona-script.js"></script>
 </head>
 <body>
  <div id="app">
   <!-- Header -->
   <header>
    <div>
     <div class="title">PiProtocol \u2013 Daily Mining</div>
     <div class="sub">24h mining \u2022 Local persistence + API fallback</div>
    </div>
   </header>
   <!-- Main -->
   <main>
    <!-- Mining -->
    <section class="tab active" id="tab-mining">
     <div class="card row">
      <div>
       <div class="kicker">Wallet Balance</div>
       <div class="big">
        <span id="balance">0</span> <span class="muted" style="font-size:14px">coins</span>
       </div>
      </div>
      <div style="text-align:end">
       <div class="kicker">Mining Status</div>
       <div id="miningStatus" class="pill">Inactive</div>
      </div>
     </div>
     <div class="card">
      <div class="row" style="align-items:flex-end">
       <div>
        <div class="kicker">Time remaining</div>
        <div id="timer" class="big">00:00:00</div>
       </div>
       <div style="text-align:end">
        <div class="kicker">Session earnings</div>
        <div class="big accent">
         <span id="sessionEarnings">0</span> coins
        </div>
       </div>
      </div>
      <div class="progress" style="margin-top:10px">
       <div id="progressBar"></div>
      </div>
      <div class="row" style="margin-top:12px">
       <button id="startBtn" class="btn btn-gold">Start 24h</button>
       <button id="claimBtn" class="btn btn-ghost" disabled>Finish & Claim</button>
      </div>
      <div class="muted" style="margin-top:8px">
       Rate: <b id="rateText">0.002</b> coin/sec \u2022 Each time you press <b>Start</b>, the timer begins from the beginning.
      </div>
     </div>
     <!-- News -->
     <div class="card">
      <div class="row" style="justify-content:space-between">
       <div class="h2">News</div>
       <div class="badge">
        <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
         <path d="M4 4h13a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3H7a3 3 0 0 1-3-3V4z" /><path d="M8 8h8M8 12h8M8 16h6" stroke="#000" stroke-opacity=".28" />
        </svg>
        Latest
       </div>
      </div>
      <ul id="newsList" style="margin:6px 0 0 0; padding:0; list-style:none"></ul>
     </div>
    </section>
    <!-- Wallet -->
    <section class="tab" id="tab-wallet">
     <div class="grid-3">
      <div class="card">
       <div class="kicker">Coins</div>
       <div class="big">
        <span id="coinsBalance">0</span>
       </div>
      </div>
      <div class="card">
       <div class="kicker">PiP</div>
       <div class="big">
        <span id="piBalance">0.00</span>
       </div>
      </div>
      <div class="card">
       <div class="kicker">USDT</div>
       <div class="big">
        <span id="usdtBalance">0.00</span>
       </div>
      </div>
     </div>
     <div class="grid-2" style="margin-top:12px">
      <!-- Convert Coins -> Pi -->
      <div class="card">
       <div class="h3">\ud83d\udd04 Convert Coins \u2192 PiP</div>
       <div class="muted" style="margin-bottom:6px">
        Display rate: <b id="coinsPerPi">100</b> coins = 1 PiP
       </div>
       <div class="input-row">
        <input id="coinsToPiAmt" type="number" min="0" step="1" placeholder="Coin amount">
        <button id="coinsToPiBtn" class="btn btn-gold">Convert</button>
       </div>
       <div id="coinsToPiHint" class="muted" style="margin-top:6px"></div>
      </div>
      <!-- Convert Pi -> USDT -->
      <div class="card">
       <div class="h3">\ud83d\udcb1 Convert PiP \u2192 USDT</div>
       <div class="muted" style="margin-bottom:6px">
        Display rate: 1 PiP = <b id="usdtPerPi">5</b> USDT
       </div>
       <div class="input-row">
        <input id="piToUsdtAmt" type="number" min="0" step="0.01" placeholder="PiP amount">
        <button id="piToUsdtBtn" class="btn btn-gold">Convert</button>
       </div>
       <div id="piToUsdtHint" class="muted" style="margin-top:6px"></div>
      </div>
     </div>
     <!-- Withdraw -->
     <div class="card" style="margin-top:12px">
      <div class="h3">\ud83c\udfe6 Withdraw</div>
      <div class="grid-3">
       <div>
        <div class="muted">Asset Type</div>
        <select id="withdrawAsset"> <option value="pi">PiP</option> <option value="usdt">USDT</option> </select>
       </div>
       <div>
        <div class="muted">Wallet Address</div>
        <input id="withdrawAddr" placeholder="e.g., Pi wallet / TRON / ERC-20">
       </div>
       <div>
        <div class="muted">Amount</div>
        <input id="withdrawAmt" type="number" min="0" step="0.01" placeholder="Amount">
       </div>
      </div>
      <div class="row" style="margin-top:10px">
       <button id="withdrawBtn" class="btn btn-gold">Submit Request</button>
       <div class="muted">For actual processing, server-side verification is required.</div>
      </div>
     </div>
     <!-- Transactions -->
     <div class="card" style="margin-top:12px">
      <div class="h3">Transactions</div>
      <table class="table">
       <thead>
        <tr>
         <th>Description</th>
         <th>Amount</th>
         <th>Time</th>
        </tr>
       </thead>
       <tbody id="txList"></tbody>
      </table>
      <div id="noTx" class="muted" style="margin-top:6px">No transactions yet.</div>
     </div>
    </section>
    <!-- Friends -->
    <section class="tab" id="tab-friends">
     <div class="card">
      <div class="h3">Your Invitation Link</div>
      <div id="refLink" class="muted" style="word-break:break-all;background:rgba(255,255,255,.08);border:1px dashed var(--border);padding:10px;border-radius:12px"></div>
      <div class="row" style="margin-top:8px">
       <button id="copyRef" class="btn btn-gold">Copy Link</button>
       <button id="shareRef" class="btn btn-ghost">Share</button>
      </div>
     </div>
     <div class="grid-3" style="margin-top:12px">
      <div class="card">
       <div class="kicker">Invited</div>
       <div class="big" id="friendsInvited">0</div>
      </div>
      <div class="card">
       <div class="kicker">Active</div>
       <div class="big" id="friendsActive">0</div>
      </div>
      <div class="card">
       <div class="kicker">Reward</div>
       <div class="big accent">+100 coins / invite</div>
      </div>
     </div>
     <!-- Invited Friends List -->
     <div class="card" style="margin-top:12px">
      <div class="h3">Invited Friends</div>
      <table class="table" id="invitedFriendsTable">
       <thead>
        <tr>
         <th>User</th>
         <th>Invite Date</th>
         <th>Status</th>
        </tr>
       </thead>
       <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:6px">
       Invitation reward: <b>100</b> coins (one-time per friend)
      </div>
     </div>
     <!-- Active Friends List -->
     <div class="card" style="margin-top:12px">
      <div class="h3">Active Friends</div>
      <table class="table" id="activeFriendsTable">
       <thead>
        <tr>
         <th>User</th>
         <th>Activation Date</th>
         <th>Speed Boost</th>
        </tr>
       </thead>
       <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:6px">
       Mining speed boost: <b>+0.001</b> for each active friend
      </div>
     </div>
     <!-- Leaderboard -->
     <div class="card" style="margin-top:12px">
      <div class="h3">Top Ranks (Top 10)</div>
      <table class="table" id="leaderTable">
       <thead>
        <tr>
         <th>#</th>
         <th>User</th>
         <th>Coins</th>
        </tr>
       </thead>
       <tbody></tbody>
      </table>
      <div class="muted" style="margin-top:6px">
       Your rank: <b id="myRank">#\u2014</b>
      </div>
     </div>
    </section>
    <!-- Tasks -->
    <section class="tab" id="tab-tasks">
     <div class="card">
      <div class="h3">Daily & Social Tasks</div>
      <div id="tasksWrap"></div>
      <div class="muted" style="margin-top:6px">* For actual link verification, backend is required.</div>
     </div>
     <div class="card" style="margin-top:12px">
      <div class="h3">\u2692\ufe0f Manual Mining</div>
      <div class="row">
       <div class="muted">+0.5 coin per click (Cooldown 10s)</div>
       <button id="manualMineBtn" class="btn btn-gold">Mine +0.5</button>
      </div>
      <div id="manualCooldown" class="muted" style="margin-top:6px"></div>
     </div>
    </section>
    <!-- Profile -->
    <section class="tab" id="tab-profile">
     <div class="card">
      <div class="h3">Profile</div>
      <div class="input-row" style="margin-top:6px">
       <input id="firstName" placeholder="First Name"> <input id="lastName" placeholder="Last Name"> <input id="userId" placeholder="User ID">
       <button id="saveProfile" class="btn btn-gold">Save</button>
      </div>
      <div class="muted" style="margin-top:6px">Information is saved on this device only.</div>
     </div>
    </section>
   </main>
   <!-- Tabs bar -->
   <nav class="tabs">
    <div class="tabs-inner">
     <button class="tab-btn active" data-tab="mining">Mining <span class="mini">24h</span></button>
     <button class="tab-btn" data-tab="wallet">Wallet <span class="mini">Convert</span></button>
     <button class="tab-btn" data-tab="friends">Friends <span class="mini">Rank</span></button>
     <button class="tab-btn" data-tab="tasks">Tasks <span class="mini">Daily</span></button>
     <button class="tab-btn" data-tab="profile">Profile <span class="mini">You</span></button>
    </div>
   </nav>
  </div>
  <!-- Share Modal -->
  <div id="shareModal" class="share-modal">
   <div class="share-modal-content">
    <div class="h3">Share Invitation Link</div>
    <div class="muted">Share your invitation link through these apps</div>
    <div class="share-apps">
     <div class="share-app" data-app="whatsapp">
      <svg viewBox="0 0 24 24" fill="#25D366">
       <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893A11.821 11.821 0 0020.864 3.488" />
      </svg>
      <span>WhatsApp</span>
     </div>
     <div class="share-app" data-app="telegram">
      <svg viewBox="0 0 24 24" fill="#0088cc">
       <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.894 8.221l-1.97 9.28c-.145.658-.537.818-1.084.508l-3-2.21-1.447 1.394c-.16.16-.295.295-.605.295l.213-3.053 5.56-5.022c.242-.213-.054-.334-.373-.121l-6.869 4.326-2.96-.924c-.64-.203-.658-.64.136-.954l11.566-4.458c.538-.196 1.006.128.832.941z" />
      </svg>
      <span>Telegram</span>
     </div>
     <div class="share-app" data-app="imo">
      <svg viewBox="0 0 24 24" fill="#1ddbcf">
       <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22C6.5 22 2 17.5 2 12S6.5 2 12 2s10 4.5 10 10-4.5 10-10 10z" /> <path d="M12 5c-3.9 0-7 3.1-7 7s3.1 7 7 7 7-3.1 7-7-3.1-7-7-7zm0 12c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5z" /> <circle cx="12" cy="12" r="2.5" />
      </svg>
      <span>Imo</span>
     </div>
     <div class="share-app" data-app="copy">
      <svg viewBox="0 0 24 24" fill="#9e9e9e">
       <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
      </svg>
      <span>Copy</span>
     </div>
     <div class="share-app" data-app="more">
      <svg viewBox="0 0 24 24" fill="#9e9e9e">
       <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
      </svg>
      <span>More</span>
     </div>
    </div>
    <div class="row" style="margin-top:15px; justify-content:flex-end">
     <button id="closeShareModal" class="btn btn-ghost">Close</button>
    </div>
   </div>
  </div>
  <script>
/* ================== Config ================== */
const API_BASE = 'https://pinet-backend-production.up.railway.app'; // Backend base (provided)
const STORAGE_KEY = 'pinet_clicker_state_v5';
const DURATION_MS = 24*60*60*1000;  // 24 hours
const RATE_PER_SEC = 0.002;          // coins/sec demo
const COINS_PER_PI = 100;           // 100 coins => 1 Pi
const USDT_PER_PI  = 5;             // 1 Pi => 5 USDT
const REF_REWARD   = 30;            // coins per active friend
const MANUAL_GAIN  = 0.5;
const MANUAL_COOLDOWN = 10*1000;

/* ================== State ================== */
const state = load() || {
  coins: 0, pi: 0, usdt: 0,
  tx: [],                 // {id,type,amount,ts,note}
  miningStart: null,
  friendsInvited: 0, friendsActive: 0,
  invitedFriends: [],     // [{id, username, inviteDate, isActive}]
  activeFriends: [],      // [{id, username, activeDate}]
  rewardedFriends: [],    // [id1, id2, ...] - IDs of friends who have already been rewarded
  profile: { first:'', last:'', id:'' },
  myRank: 112131,
  completedTasks: [],
  lastManual: 0,
  taskStatuses: {},
  lastResetDate: new Date().toDateString()
};

/* ================== Elements ================== */
// Mining
const $ = (id)=>document.getElementById(id);
const balanceEl = $('balance');
const miningStatusEl = $('miningStatus');
const timerEl = $('timer');
const sessionEarningsEl = $('sessionEarnings');
const progressBarEl = $('progressBar');
const rateText = $('rateText');
const startBtn = $('startBtn');
const claimBtn = $('claimBtn');

// Wallet
const coinsBalanceEl = $('coinsBalance');
const piBalanceEl = $('piBalance');
const usdtBalanceEl = $('usdtBalance');
const coinsToPiAmt = $('coinsToPiAmt');
const coinsToPiBtn = $('coinsToPiBtn');
const coinsToPiHint = $('coinsToPiHint');
const piToUsdtAmt = $('piToUsdtAmt');
const piToUsdtBtn = $('piToUsdtBtn');
const piToUsdtHint = $('piToUsdtHint');
const withdrawAsset = $('withdrawAsset');
const withdrawAddr = $('withdrawAddr');
const withdrawAmt = $('withdrawAmt');
const withdrawBtn = $('withdrawBtn');
const txListEl = $('txList');
const noTxEl = $('noTx');

// Friends
const refLinkEl = $('refLink');
const copyRefBtn = $('copyRef');
const shareRefBtn = $('shareRef');
const friendsInvitedEl = $('friendsInvited');
const friendsActiveEl = $('friendsActive');
const leaderTable = $('leaderTable').querySelector('tbody');
const myRankEl = $('myRank');

// Tasks
const tasksWrap = $('tasksWrap');
const manualMineBtn = $('manualMineBtn');
const manualCooldownEl = $('manualCooldown');

// Profile
const firstNameInput = $('firstName');
const lastNameInput  = $('lastName');
const userIdInput    = $('userId');
const saveProfileBtn = $('saveProfile');

// Header

// News
const newsListEl = $('newsList');

// Share Modal
const shareModal = $('shareModal');
const closeShareModal = $('closeShareModal');
const shareApps = document.querySelectorAll('.share-app');

// Misc
$('coinsPerPi').textContent = COINS_PER_PI;
$('usdtPerPi').textContent  = USDT_PER_PI;
rateText && (rateText.textContent = RATE_PER_SEC.toString());

/* ================== Tabs ================== */
document.querySelectorAll('.tab-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('section.tab').forEach(s=>s.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-'+btn.dataset.tab).classList.add('active');
  });
});

/* ================== Mining Logic ================== */
let tickId=null;

function formatHHMMSS(ms){
  const s = Math.max(0, Math.floor(ms/1000));
  const h = String(Math.floor(s/3600)).padStart(2,'0');
  const m = String(Math.floor((s%3600)/60)).padStart(2,'0');
  const ss= String(s%60).padStart(2,'0');
  return `${h}:${m}:${ss}`;
}
function miningMetrics(){
  if(!state.miningStart) return {elapsed:0, remaining:0, progress:0, rewardNow:0};
  const now = Date.now();
  const elapsed = Math.max(0, now - state.miningStart);
  const remaining = Math.max(0, DURATION_MS - elapsed);
  const clamped = Math.min(elapsed, DURATION_MS);
  
  // Calculate base rate plus bonus from active friends
  const activeFriendsBonus = (state.friendsActive || 0) * 0.001;
  const effectiveRate = RATE_PER_SEC + activeFriendsBonus;
  
  const rewardNow = (clamped/1000) * effectiveRate;
  const progress = (clamped / DURATION_MS) * 100;
  return {elapsed, remaining, progress, rewardNow, effectiveRate};
}
function runTick(){
  clearInterval(tickId);
  tick();
  tickId = setInterval(tick, 1000);
}

function tick(){
  // If mining is not active, show default state
  if(!state.miningStart){
    miningStatusEl.textContent='Inactive';
    miningStatusEl.className='pill';
    claimBtn.disabled=true;
    timerEl.textContent='00:00:00';
    sessionEarningsEl.textContent='0';
    progressBarEl.style.width='0%';
    startBtn.disabled = false; // Enable start button when not mining
    return;
  }

  const {remaining, progress, rewardNow} = miningMetrics();
  timerEl.textContent = formatHHMMSS(remaining);
  sessionEarningsEl.textContent = rewardNow.toFixed(3); // Show 3 decimal places
  progressBarEl.style.width = `${progress}%`;

  // When timer finishes: enable Claim button and change status to Completed
  if(remaining<=0){
    clearInterval(tickId); tickId=null;
    claimBtn.disabled=false;
    startBtn.disabled = false; // Enable start button when timer completes
    miningStatusEl.textContent='Completed \u2013 claim pending';
    miningStatusEl.className='pill warn';
  }else{
    claimBtn.disabled=true;
    startBtn.disabled = true; // Disable start button while mining is active
    miningStatusEl.textContent='Active';
    miningStatusEl.className='pill good';
  }
}

startBtn.addEventListener('click', async ()=>{
  // Each time Start is pressed: timer starts from the beginning
  state.miningStart = Date.now();
  pushTx({type:'info', amount:0, note:'Started 24h mining', ts: Date.now()});
  save(); updateMiningUI(); runTick();
  
  // Disable start button while mining is active
  startBtn.disabled = true;

  // Optional: ping backend (ignore failure)
  try{
    await fetch(`${API_BASE}/mining/start`,{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({ts:state.miningStart})});
  }catch(e){}
});
claimBtn.addEventListener('click', async ()=>{
  // If mining hasn't started, or timer hasn't finished, don't allow
  if(!state.miningStart) return;
  const {remaining, rewardNow} = miningMetrics();

  // If not yet complete, don't allow (emergency)
  if(remaining>0) return alert('Timer has not finished yet.');

  const reward = Number(rewardNow.toFixed(3)); // Use 3 decimal places
  if(reward>0){
    state.coins += reward;
    pushTx({type:'earn', amount:reward, note:'Mining session reward', ts: Date.now()});
  }

  // Clear mining session (waiting for user to start again)
  state.miningStart = null;
  save();
  updateMiningUI();
  renderWallet();

  // Send to server (optional, ignore errors)
  try{
    await fetch(`${API_BASE}/claim`,{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({amount:reward, ts: Date.now()})});
  }catch(e){}
});

function updateMiningUI(){
  // Simply perform the render with the same tick logic (to always be in sync)
  if(state.miningStart){
    // If mining is active, display status based on metrics
    const {remaining, progress, rewardNow, effectiveRate} = miningMetrics();
    timerEl.textContent = formatHHMMSS(remaining);
    sessionEarningsEl.textContent = rewardNow.toFixed(3); // Show 3 decimal places
    progressBarEl.style.width = `${progress}%`;
    
    // Update the displayed mining rate to include active friends bonus
    if (rateText) {
      rateText.textContent = effectiveRate.toFixed(3);
    }

    if(remaining <= 0){
      claimBtn.disabled = false;
      startBtn.disabled = false; // Enable start button when timer completes
      miningStatusEl.textContent = 'Completed \u2013 claim pending';
      miningStatusEl.className = 'pill warn';
    }else{
      claimBtn.disabled = true;
      startBtn.disabled = true; // Disable start button while mining is active
      miningStatusEl.textContent = 'Active';
      miningStatusEl.className = 'pill good';
    }
  }else{
    // When miningStart is null, disable Claim button
    claimBtn.disabled = true;
    startBtn.disabled = false; // Enable start button when not mining
    miningStatusEl.textContent = 'Inactive';
    miningStatusEl.className = 'pill';
    timerEl.textContent='00:00:00';
    sessionEarningsEl.textContent='0.000';
    progressBarEl.style.width='0%';
    
    // Update the displayed mining rate to include active friends bonus
    const activeFriendsBonus = (state.friendsActive || 0) * 0.001;
    const effectiveRate = RATE_PER_SEC + activeFriendsBonus;
    if (rateText) {
      rateText.textContent = effectiveRate.toFixed(3);
    }
  }

  // Display coin balance with 3 decimal places
  balanceEl.textContent = state.coins.toFixed(3);
}

/* ================== Wallet & Conversions ================== */
function renderWallet(){
  // Display coin balance with 3 decimal places
  coinsBalanceEl.textContent = state.coins.toFixed(3);
  piBalanceEl.textContent = Number(state.pi).toFixed(2);
  usdtBalanceEl.textContent = Number(state.usdt).toFixed(2);

  // transactions
  txListEl.innerHTML='';
  if(!state.tx.length){ noTxEl.style.display='block'; return; }
  noTxEl.style.display='none';
  state.tx.slice(0,80).forEach(t=>{
    const tr = document.createElement('tr');
    const td1 = document.createElement('td'); td1.innerHTML = `<div>${t.note||'\u2014'}</div><div class="muted">${t.type}</div>`;
    const td2 = document.createElement('td'); td2.textContent = (t.type==='earn'?'+':'') + Number(t.amount).toFixed(3); // Show 3 decimal places
    const td3 = document.createElement('td'); td3.className='muted'; td3.textContent = new Date(t.ts||Date.now()).toLocaleString();
    tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
    txListEl.appendChild(tr);
  });
}

coinsToPiBtn.addEventListener('click', async ()=>{
  const coins = Math.max(0, Math.floor(Number(coinsToPiAmt.value||0)));
  if(!coins) return alert('Enter a valid amount');
  if(coins > state.coins) return alert('Insufficient coin balance');
  const pi = coins / COINS_PER_PI;
  state.coins -= coins; state.pi += pi;
  pushTx({type:'swap', amount:pi, note:`Convert ${coins} coins \u2192 ${pi.toFixed(2)} Pi`, ts: Date.now()});
  save(); renderWallet(); updateMiningUI();
  coinsToPiAmt.value='';
  coinsToPiHint.textContent = `\u2248 ${pi.toFixed(2)} Pi`;
  try{
    await fetch(`${API_BASE}/convert/coins-to-pi`,{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({coins, pi})});
  }catch(e){}
});

piToUsdtBtn.addEventListener('click', async ()=>{
  const pi = Math.max(0, Number(piToUsdtAmt.value||0));
  if(!pi) return alert('Enter a valid amount');
  if(pi > state.pi) return alert('Insufficient Pi balance');
  const usdt = pi * USDT_PER_PI;
  state.pi -= pi; state.usdt += usdt;
  pushTx({type:'swap', amount:usdt, note:`Convert ${pi} Pi \u2192 ${usdt.toFixed(2)} USDT`, ts: Date.now()});
  save(); renderWallet();
  piToUsdtAmt.value='';
  piToUsdtHint.textContent = `\u2248 ${usdt.toFixed(2)} USDT`;
  try{
    await fetch(`${API_BASE}/convert/pi-to-usdt`,{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({pi, usdt})});
  }catch(e){}
});

withdrawBtn.addEventListener('click', async ()=>{
  const asset = withdrawAsset.value;
  const addr = withdrawAddr.value.trim();
  const amt = Math.max(0, Number(withdrawAmt.value||0));
  if(!addr || !amt) return alert('Please complete all fields');
  if(asset==='pi' && amt>state.pi) return alert('Insufficient Pi balance');
  if(asset==='usdt' && amt>state.usdt) return alert('Insufficient USDT balance');

  // Local: just record display transaction
  pushTx({type:'withdraw', amount:amt, note:`Withdraw request ${amt} ${asset.toUpperCase()} \u2192 ${addr.slice(0,12)}...`, ts: Date.now()});
  save(); renderWallet();

  try{
    const res = await fetch(`${API_BASE}/withdraw`,{
      method:'POST', headers:{'Content-Type':'application/json'},
      body:JSON.stringify({asset, address:addr, amount:amt})
    });
    // If needed: check response
  }catch(e){}
  alert('Withdrawal request submitted (demo). For actual withdrawal, backend verification is required.');
});

/* ================== Friends & Rank ================== */
const FAKE_TOP10 = ['ShadowFox','NovaStar','PixelWave','IronClad','BlueComet','SilentPeak','QuantumBee','BrightMint','ArcticFlame','NeonDash'];

// New function to fetch friends data from API
async function fetchFriendsData() {
  try {
    const userId = state.profile.id || rid().slice(0,6);
    const response = await fetch(`${API_BASE}/referral/stats`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ userId })
    });
    
    if (response.ok) {
      const data = await response.json();
      
      // Update state with the fetched data
      if (data.invited !== undefined) {
        state.friendsInvited = data.invited;
      }
      if (data.active !== undefined) {
        state.friendsActive = data.active;
      }
      
      // Process invited friends data if available
      if (data.invitedFriends && Array.isArray(data.invitedFriends)) {
        state.invitedFriends = data.invitedFriends;
        
        // Check for new invited friends to reward (one-time 100 coin reward)
        data.invitedFriends.forEach(friend => {
          if (!state.rewardedFriends.includes(friend.id)) {
            // Add 100 coins reward for new invited friend
            state.coins += 100;
            state.rewardedFriends.push(friend.id);
            
            // Add transaction record
            pushTx({
              type: 'earn', 
              amount: 100, 
              note: `Referral reward for inviting ${friend.username || 'a friend'}`, 
              ts: Date.now()
            });
          }
        });
      }
      
      // Process active friends data if available
      if (data.activeFriends && Array.isArray(data.activeFriends)) {
        state.activeFriends = data.activeFriends;
      }
      
      // If no data from API, generate some fake data for demo purposes
      if (!state.invitedFriends || state.invitedFriends.length === 0) {
        generateFakeFriendsData();
      }
      
      save();
      renderFriendsBox();
      renderFriendsTables();
      updateMiningUI(); // Update UI to reflect new mining rate with active friends bonus
      renderWallet();
    }
  } catch (e) {
    console.error('Failed to fetch friends data:', e);
    // If API fails, generate fake data for demo
    generateFakeFriendsData();
    renderFriendsBox();
    renderFriendsTables();
  }
}

// Generate fake friends data for demo purposes
function generateFakeFriendsData() {
  const fakeNames = ['Alex', 'Michael', 'Sarah', 'Maria', 'Robert', 'Henry', 'Fatima', 'Zoe', 'Amir', 'Nina'];
  
  // Generate invited friends
  if (!state.invitedFriends || state.invitedFriends.length === 0) {
    state.invitedFriends = [];
    const invitedCount = Math.min(state.friendsInvited || 0, 10);
    
    for (let i = 0; i < invitedCount; i++) {
      const isActive = i < (state.friendsActive || 0);
      const daysAgo = Math.floor(Math.random() * 30) + 1;
      const inviteDate = new Date();
      inviteDate.setDate(inviteDate.getDate() - daysAgo);
      
      state.invitedFriends.push({
        id: 'inv_' + rid().slice(0, 8),
        username: fakeNames[Math.floor(Math.random() * fakeNames.length)],
        inviteDate: inviteDate.toISOString(),
        isActive: isActive
      });
    }
  }
  
  // Generate active friends
  if (!state.activeFriends || state.activeFriends.length === 0) {
    state.activeFriends = [];
    const activeCount = Math.min(state.friendsActive || 0, state.invitedFriends.length);
    
    for (let i = 0; i < activeCount; i++) {
      if (i < state.invitedFriends.length && state.invitedFriends[i].isActive) {
        const daysAgo = Math.floor(Math.random() * 15) + 1;
        const activeDate = new Date();
        activeDate.setDate(activeDate.getDate() - daysAgo);
        
        state.activeFriends.push({
          id: state.invitedFriends[i].id,
          username: state.invitedFriends[i].username,
          activeDate: activeDate.toISOString()
        });
      }
    }
  }
  
  // Initialize rewardedFriends if needed
  if (!state.rewardedFriends) {
    state.rewardedFriends = [];
  }
}

function setupFriends(){
  // referral link + backend registration
  const base = "https://t.me/piprotocolbot"; 
  const userCode = state.profile.id || rid().slice(0,6); 
  const myLink = `${base}?start=${encodeURIComponent(userCode)}`;
  refLinkEl.textContent = myLink;

  // Fetch friends data from API
  fetchFriendsData();

  // Check if entered through invitation link
  const urlParams = new URLSearchParams(window.location.search);
  const inviterCode = urlParams.get('start');
  if(inviterCode && inviterCode !== userCode){
    // Register the referral
    fetch(`${API_BASE}/referral/register`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ inviterCode, userId: userCode })
    })
    .then(response => {
      if(response.ok) {
        // If registration successful, increment the inviter's count locally
        // This is just for UI feedback, the actual count comes from the API
        return response.json();
      }
      throw new Error('Referral registration failed');
    })
    .then(data => {
      // If we get a successful response, update the local state
      if(data && data.success) {
        pushTx({type:'info', amount:0, note:`Joined via invite ${inviterCode}`, ts: Date.now()});
        save();
        renderWallet();
        
        // Refresh friends data after registration
        fetchFriendsData();
      }
    })
    .catch(e => console.error('Referral registration failed', e));
  }

  copyRefBtn.addEventListener('click', async ()=>{ 
    try{ 
      await navigator.clipboard.writeText(myLink); 
      alert('Invitation link copied!');
    }catch(e){
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = myLink;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      alert('Invitation link copied!');
    } 
  });

  // Share button
  shareRefBtn.addEventListener('click', ()=>{
    shareModal.style.display = 'flex';
  });

  // Close modal
  closeShareModal.addEventListener('click', ()=>{
    shareModal.style.display = 'none';
  });

  // Share apps functionality
  shareApps.forEach(app => {
    app.addEventListener('click', () => {
      const appType = app.dataset.app;
      shareLink(myLink, appType);
      
      // Track share event - this could potentially count as an invite
      trackShareEvent(appType);
    });
  });

  // leaderboard
  leaderTable.innerHTML = '';
  FAKE_TOP10.forEach((n,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `<td>${i+1}</td><td>${n}</td><td>${(200 - i*10)}</td>`;
    leaderTable.appendChild(tr);
  });
  myRankEl.textContent = `#${state.myRank}`;

  renderFriendsBox();
  renderFriendsTables();

  // if joined via ?ref (client-side info only)
  const url = new URL(location.href); const ref = url.searchParams.get('ref');
  if(ref){ 
    pushTx({type:'info', amount:0, note:`Joined via invite ${ref}`, ts: Date.now()}); 
    save(); 
    renderWallet(); 
  }
}

// Track share events
function trackShareEvent(platform) {
  try {
    fetch(`${API_BASE}/referral/share`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ 
        userId: state.profile.id || rid().slice(0,6),
        platform
      })
    });
    
    // Optimistically increment invited count for better UX
    // The real count will be updated from the API later
    state.friendsInvited++;
    
    // Add the shared friend to invitedFriends list
    const fakeNames = ['Alex', 'Michael', 'Sarah', 'Maria', 'Robert', 'Henry', 'Fatima', 'Zoe', 'Amir', 'Nina'];
    const randomName = fakeNames[Math.floor(Math.random() * fakeNames.length)];
    
    const newFriend = {
      id: 'inv_' + rid().slice(0, 8),
      username: randomName,
      inviteDate: new Date().toISOString(),
      isActive: false
    };
    
    if (!state.invitedFriends) {
      state.invitedFriends = [];
    }
    
    state.invitedFriends.push(newFriend);
    
    // Check if this friend should be rewarded
    if (!state.rewardedFriends.includes(newFriend.id)) {
      state.coins += 100;
      state.rewardedFriends.push(newFriend.id);
      
      // Add transaction record
      pushTx({
        type: 'earn', 
        amount: 100, 
        note: `Referral reward for inviting ${newFriend.username}`, 
        ts: Date.now()
      });
    }
    
    renderFriendsBox();
    renderFriendsTables();
    renderWallet();
    updateMiningUI();
    save();
  } catch(e) {
    console.error('Failed to track share event:', e);
  }
}

// Add a function to manually update friends count (for testing or when API is unavailable)
function updateFriendsCount(invited, active) {
  if (typeof invited === 'number') {
    state.friendsInvited = invited;
  }
  if (typeof active === 'number') {
    state.friendsActive = active;
  }
  save();
  renderFriendsBox();
}

function shareLink(link, appType) {
  let shareUrl = '';

  switch(appType) {
    case 'whatsapp':
      shareUrl = `https://wa.me/?text=${encodeURIComponent(link)}`;
      break;
    case 'telegram':
      shareUrl = `https://t.me/share/url?url=${encodeURIComponent(link)}`;
      break;
    case 'imo':
      // Imo share URL
      shareUrl = `imo://share?text=${encodeURIComponent(link)}`;
      break;
    case 'copy':
      navigator.clipboard.writeText(link);
      alert('Invitation link copied!');
      return;
    case 'more':
      if (navigator.share) {
        navigator.share({
          title: 'PiProtocol Invitation',
          text: 'Join PiProtocol and start mining!',
          url: link
        }).catch(console.error);
      } else {
        alert(`Invitation link: ${link}`);
      }
      return;
  }

  window.open(shareUrl, '_blank');
}

function renderFriendsBox(){
  friendsInvitedEl.textContent = state.friendsInvited;
  friendsActiveEl.textContent = state.friendsActive;
}

// Render the invited and active friends tables
function renderFriendsTables() {
  const invitedTable = document.getElementById('invitedFriendsTable').querySelector('tbody');
  const activeTable = document.getElementById('activeFriendsTable').querySelector('tbody');
  
  // Clear tables
  invitedTable.innerHTML = '';
  activeTable.innerHTML = '';
  
  // Render invited friends table
  if (state.invitedFriends && state.invitedFriends.length > 0) {
    state.invitedFriends.forEach(friend => {
      const tr = document.createElement('tr');
      
      const tdName = document.createElement('td');
      tdName.textContent = friend.username || 'User';
      
      const tdDate = document.createElement('td');
      const inviteDate = new Date(friend.inviteDate);
      tdDate.textContent = inviteDate.toLocaleDateString();
      
      const tdStatus = document.createElement('td');
      if (friend.isActive) {
        tdStatus.innerHTML = '<span class="pill good">Active</span>';
      } else {
        tdStatus.innerHTML = '<span class="pill">Inactive</span>';
      }
      
      tr.appendChild(tdName);
      tr.appendChild(tdDate);
      tr.appendChild(tdStatus);
      invitedTable.appendChild(tr);
    });
  } else {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 3;
    td.textContent = 'No friends invited yet';
    td.className = 'muted';
    td.style.textAlign = 'center';
    tr.appendChild(td);
    invitedTable.appendChild(tr);
  }
  
  // Render active friends table
  if (state.activeFriends && state.activeFriends.length > 0) {
    state.activeFriends.forEach(friend => {
      const tr = document.createElement('tr');
      
      const tdName = document.createElement('td');
      tdName.textContent = friend.username || 'User';
      
      const tdDate = document.createElement('td');
      const activeDate = new Date(friend.activeDate);
      tdDate.textContent = activeDate.toLocaleDateString();
      
      const tdBonus = document.createElement('td');
      tdBonus.textContent = '+0.001';
      tdBonus.className = 'accent';
      
      tr.appendChild(tdName);
      tr.appendChild(tdDate);
      tr.appendChild(tdBonus);
      activeTable.appendChild(tr);
    });
  } else {
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 3;
    td.textContent = 'No active friends yet';
    td.className = 'muted';
    td.style.textAlign = 'center';
    tr.appendChild(td);
    activeTable.appendChild(tr);
  }
}

/* ================== Tasks (Daily + Social + Manual) ================== */
const TASKS = [
  { 
    id:'daily',   
    title:'\ud83c\udf81 Daily Reward', 
    kind:'daily', 
    reward:15, 
    url:'' 
  },
  { 
    id:'yt_subscribe',      
    title:'\u25b6\ufe0f Subscribe to YouTube Channel', 
    kind:'social', 
    reward:20, 
    url:'https://youtube.com/@YouTubeChannel',
    status: 'start' // start, checking, claim
  },
  { 
    id:'yt_like',      
    title:'\ud83d\udc4d Like a YouTube Video', 
    kind:'social', 
    reward:20, 
    url:'https://youtube.com/watch?v=example',
    status: 'start'
  },
  { 
    id:'yt_comment',      
    title:'\ud83d\udcac Comment on YouTube Channel', 
    kind:'social', 
    reward:20, 
    url:'https://youtube.com/channel/example',
    status: 'start'
  },
  { 
    id:'tg_react',      
    title:'\ud83d\udd25 React to a Telegram Post', 
    kind:'social', 
    reward:20, 
    url:'https://t.me/channel/123',
    status: 'start'
  },
  { 
    id:'tg_comment',      
    title:'\ud83d\udcac Comment on a Telegram Post', 
    kind:'social', 
    reward:20, 
    url:'https://t.me/channel/123',
    status: 'start'
  }
];


/* ================== Daily Reset Functions ================== */

// Check if daily tasks need to be reset
function checkAndResetDailyTasks() {
  const today = new Date().toDateString();

  // If today's date is different from the last reset date
  if (state.lastResetDate !== today) {
    console.log('Resetting tasks for new day');
    resetDailyTasks();
    state.lastResetDate = today;
    save();
  }
}

// Reset daily tasks
function resetDailyTasks() {
  console.log('Resetting daily tasks...');

  // Reset daily task status
  if (!state.taskStatuses) {
    state.taskStatuses = {};
  }
  
  // Set daily task to claimable state
  state.taskStatuses['daily'] = 'claim';
  
  // Remove daily task from completed tasks list
  const dailyIndex = state.completedTasks.indexOf('daily');
  if (dailyIndex > -1) {
    state.completedTasks.splice(dailyIndex, 1);
  }

  // Reset other tasks if needed
  TASKS.forEach(task => {
    if (task.id !== 'daily') {
      // Reset status to start for all tasks except daily
      state.taskStatuses[task.id] = 'start';

      // Remove from completedTasks
      const index = state.completedTasks.indexOf(task.id);
      if (index > -1) {
        state.completedTasks.splice(index, 1);
      }
    }
  });

  save();
  renderTasks();
}


function setupTasks(){
  renderTasks();
  manualMineBtn.addEventListener('click', ()=>{
    const now = Date.now();
    const remaining = state.lastManual ? (MANUAL_COOLDOWN - (now - state.lastManual)) : 0;
    if(remaining>0){
      manualCooldownEl.textContent = `Cooldown: ${Math.ceil(remaining/1000)}s`;
      return;
    }
    state.coins += MANUAL_GAIN;
    state.lastManual = now;
    manualCooldownEl.textContent = `Cooldown: ${MANUAL_COOLDOWN/1000}s`;
    pushTx({type:'earn', amount:MANUAL_GAIN, note:'Manual mining click', ts: Date.now()});
    save(); renderWallet(); updateMiningUI();

    const iv = setInterval(()=>{
      const r = MANUAL_COOLDOWN - (Date.now() - state.lastManual);
      if(r<=0){ manualCooldownEl.textContent=''; clearInterval(iv); }
      else manualCooldownEl.textContent = `Cooldown: ${Math.ceil(r/1000)}s`;
    }, 250);
  });
}

function renderTasks(){
  tasksWrap.innerHTML='';

  // Add reset information at the top of tasks
  const resetHeader = document.createElement('div');
  resetHeader.className = 'muted';
  resetHeader.style.marginBottom = '15px';
  resetHeader.style.textAlign = 'center';
  resetHeader.style.fontSize = '12px';
  resetHeader.id = 'resetTimer';

  // Use stored time or calculate new
  let timeUntilReset = state.timeUntilReset;
  if (!timeUntilReset) {
    const now = new Date();
    const resetTime = new Date();
    resetTime.setHours(24, 0, 0, 0);
    timeUntilReset = resetTime - now;
    if (timeUntilReset < 0) {
      resetTime.setDate(resetTime.getDate() + 1);
      timeUntilReset = resetTime - now;
    }
  }

  const hours = Math.floor(timeUntilReset / (1000 * 60 * 60));
  const minutes = Math.floor((timeUntilReset % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((timeUntilReset % (1000 * 60)) / 1000);

  resetHeader.textContent = `Next reset: ${hours} hours, ${minutes} minutes, and ${seconds} seconds`;
  tasksWrap.appendChild(resetHeader);

  // Rest of the code unchanged...
  TASKS.forEach(t=>{
    const isDailyTask = t.id === 'daily';
    const isCompleted = state.completedTasks.includes(t.id);
    const taskStatus = isDailyTask ? (isCompleted ? 'completed' : 'claim') : (state.taskStatuses[t.id] || 'start');

    const row = document.createElement('div');
    row.className='row'; 
    row.style.margin='12px 0';
    row.style.padding='12px';
    row.style.border='1px solid var(--border)';
    row.style.borderRadius='12px';
    row.style.backgroundColor='rgba(255,255,255,0.05)';
    row.style.alignItems = 'center';

    const left = document.createElement('div'); 
    left.style.flex = '1';
    left.innerHTML = `
      <div><b>${t.title}</b></div>
      <div class="muted">+${t.reward} coins</div>
    `;

    const right = document.createElement('div');

    const actionBtn = document.createElement('button'); 
    actionBtn.className = 'btn';

    switch(taskStatus) {
      case 'start':
        actionBtn.className = 'btn btn-gold';
        actionBtn.textContent = 'Start';
        actionBtn.disabled = false;
        break;
      case 'checking':
        actionBtn.className = 'btn btn-secondary';
        actionBtn.textContent = 'Checking...';
        actionBtn.disabled = true;
        break;
      case 'claim':
        actionBtn.className = 'btn btn-success';
        actionBtn.textContent = 'Claim';
        actionBtn.disabled = false;
        break;
      case 'completed':
        actionBtn.className = 'btn btn-ghost';
        actionBtn.textContent = 'Completed';
        actionBtn.disabled = true;
        break;
    }

    actionBtn.addEventListener('click', () => {
      if (taskStatus === 'start') {
        // Open link in relevant software
        if (t.url) {
          window.open(t.url, '_blank');
        }
        handleTaskAction(t.id);
      } else if (taskStatus === 'claim') {
        claimTaskReward(t.id, t.reward, t.title);
      }
    });

    right.appendChild(actionBtn);
    row.appendChild(left); 
    row.appendChild(right);
    tasksWrap.appendChild(row);
  });
}

function handleTaskAction(taskId) {
  // Change task status to checking
  const task = TASKS.find(t => t.id === taskId);
  if (task) {
    task.status = 'checking';

    // Save status in state
    if (!state.taskStatuses) state.taskStatuses = {};
    state.taskStatuses[taskId] = 'checking';
    save();

    // Re-render tasks
    renderTasks();

    // Set timer to change status to claim after 1 minute
    setTimeout(() => {
      task.status = 'claim';
      if (state.taskStatuses) {
        state.taskStatuses[taskId] = 'claim';
      }
      save();
      renderTasks();
    }, 60000); // 1 minute
  }
}

function claimTaskReward(taskId, reward, title) {
  // Pay reward
  state.coins += reward;
  state.completedTasks.push(taskId);

  // Change task status to completed
  const task = TASKS.find(t => t.id === taskId);
  if (task) {
    task.status = 'completed';
  }

  if (!state.taskStatuses) state.taskStatuses = {};
  state.taskStatuses[taskId] = 'completed';

  pushTx({type:'earn', amount:reward, note:`Task: ${title}`, ts: Date.now()});
  save(); 
  renderTasks(); 
  renderWallet(); 
  updateMiningUI();
}

/* ================== News ================== */
async function loadNews(){
  newsListEl.innerHTML = '';
  const add = (title, body)=> {
    const li = document.createElement('li');
    li.style.padding='8px 0';
    li.innerHTML = `<div><b>${title}</b></div><div class="muted">${body}</div>`;
    newsListEl.appendChild(li);
  };
  try{
    const res = await fetch(`${API_BASE}/news`,{method:'GET'});
    if(res.ok){
      const data = await res.json(); // [{title, content, published_at}]
      if(Array.isArray(data) && data.length){
        data.slice(0,6).forEach(n=> add(n.title, n.content||''));
        return;
      }
    }
    
    // Custom news items about the project, roadmap, and partners
    add('\ud83d\ude80 PiProtocol Platform 2.0 Launch', 'We are proud to announce that PiProtocol Platform 2.0 with new features and improved mining performance will be launched on October 6, 2025.');
    
    add('\ud83e\udd1d Strategic Partnership with BlockChain Solutions', 'We are pleased to announce our strategic partnership with BlockChain Solutions for developing secure and scalable infrastructure. This collaboration will allow us to provide better services to users.');
    
    add('\ud83d\udcca PiProtocol Development Roadmap for 2025', 'The PiProtocol development roadmap for 2025 has been published. In this roadmap, our plans for launching a dedicated wallet, PiP token on major blockchain networks, and a staking system with 12% annual yield have been outlined.');
    
    add('\ud83c\udfc6 Active Users Reach 100,000', 'We are proud to announce that the number of active users on the PiProtocol platform has exceeded 100,000. We thank all users for their trust and support.');
    
    add('\ud83d\udcb0 PiP Token Listing on Major Exchanges', 'The PiP token will soon be listed on several reputable cryptocurrency exchanges. This will increase liquidity and user access to the PiP token.');
    
  }catch(e){
    // Fallback news items
    add('\ud83d\ude80 PiProtocol Platform 2.0 Launch', 'We are proud to announce that PiProtocol Platform 2.0 with new features and improved mining performance will be launched on October 6, 2025.');
    
    add('\ud83e\udd1d Strategic Partnership with BlockChain Solutions', 'We are pleased to announce our strategic partnership with BlockChain Solutions for developing secure and scalable infrastructure. This collaboration will allow us to provide better services to users.');
    
    add('\ud83d\udcca PiProtocol Development Roadmap for 2025', 'The PiProtocol development roadmap for 2025 has been published. In this roadmap, our plans for launching a dedicated wallet, PiP token on major blockchain networks, and a staking system with 12% annual yield have been outlined.');
    
    add('\ud83c\udfc6 Active Users Reach 100,000', 'We are proud to announce that the number of active users on the PiProtocol platform has exceeded 100,000. We thank all users for their trust and support.');
    
    add('\ud83d\udcb0 PiP Token Listing on Major Exchanges', 'The PiP token will soon be listed on several reputable cryptocurrency exchanges. This will increase liquidity and user access to the PiP token.');
  }
}

/* ================== Profile ================== */
function setupProfile(){
  firstNameInput.value = state.profile.first||'';
  lastNameInput.value  = state.profile.last||'';
  userIdInput.value    = state.profile.id||'';
  saveProfileBtn.addEventListener('click',()=>{
    state.profile.first = firstNameInput.value.trim();
    state.profile.last  = lastNameInput.value.trim();
    state.profile.id    = userIdInput.value.trim();
    save(); alert('Saved!');
    // Update referral link if user ID changed
    setupFriends();
  });
}

/* ================== Persistence ================== */
function load(){ try{return JSON.parse(localStorage.getItem(STORAGE_KEY));}catch(e){return null;} }
function save(){ try{localStorage.setItem(STORAGE_KEY, JSON.stringify(state));}catch(e){} }
function rid(){ return (crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)); }

/* ================== Helpers ================== */
function pushTx(tx){
  state.tx.unshift(Object.assign({id:rid(), ts: Date.now()}, tx));
  // keep length reasonable
  if(state.tx.length>200) state.tx.length=200;
}

// New function to update reset timer (global)
function updateResetTimer() {
  const now = new Date();
  const resetTime = new Date();
  resetTime.setHours(24, 0, 0, 0); // 24:00 (midnight)

  // If reset time has passed, set to next day
  if (resetTime < now) {
    resetTime.setDate(resetTime.getDate() + 1);
  }

  const timeUntilReset = resetTime - now;

  if (timeUntilReset <= 0) {
    // If reset time has arrived, reset tasks
    checkAndResetDailyTasks();
    return;
  }

  const hours = Math.floor(timeUntilReset / (1000 * 60 * 60));
  const minutes = Math.floor((timeUntilReset % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((timeUntilReset % (1000 * 60)) / 1000);

  // Update timer only if we're in the Tasks tab
  const resetTimerEl = document.getElementById('resetTimer');
  if (resetTimerEl) {
    resetTimerEl.textContent = `Next reset: ${hours} hours, ${minutes} minutes, and ${seconds} seconds`;
  }

  // Save remaining time for use in other tabs
  state.timeUntilReset = timeUntilReset;
}

/* ================== Boot ================== */
function boot(){
  // Check and reset daily tasks
  checkAndResetDailyTasks();

  updateMiningUI();
  renderWallet();
  setupFriends();
  setupTasks();
  setupProfile();
  loadNews();

  // Start global timer for reset (every 1 second)
  setInterval(() => {
    updateResetTimer();
  }, 1000);
  
  // Periodically refresh friends data (every 5 minutes)
  setInterval(() => {
    fetchFriendsData();
  }, 5 * 60 * 1000);

  // Recover task statuses from state
  if (state.taskStatuses) {
    TASKS.forEach(task => {
      if (state.taskStatuses[task.id]) {
        task.status = state.taskStatuses[task.id];
      }
    });
  }

  // If mining, continue tick or if finished but not claimed, prepare UI
  if(state.miningStart){
    const {remaining} = miningMetrics();
    if(remaining>0) {
      runTick();
      startBtn.disabled = true; // Disable start button while mining is active
    }
    else {
      // Timer finished but user hasn't claimed yet \u2014 just update UI so button is active
      updateMiningUI();
      startBtn.disabled = false; // Enable start button when timer completes
    }
  } else {
    startBtn.disabled = false; // Enable start button when not mining
  }
}
boot();

</script>
 </body>
</html>
